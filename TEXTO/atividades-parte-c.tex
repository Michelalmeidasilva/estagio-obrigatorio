\section{Estudo de Agentes Conversacionais: Fluxos Determinísticos (Período: 01/11 a 15/11)}

\subsection{Contextualização do Estudo}
Este estudo teve como objetivo compreender os fundamentos de \textit{Conversational Agents}, focando especificamente em fluxos deterministicos. Os estudos envolveu o aprendizado de como estruturar conversas rígidas e controladas usando Máquinas de Estados Finitas (FSM).

\subsection{Objetivos de Aprendizado}
\textbf{Objetivo Principal:} Desenvolver competências em design de fluxos determinísticos (\textit{Flows}) para processos que exigem alta confiabilidade e auditabilidade.

O estudo focou em compreender como garantir que cada etapa de um fluxo conversacional seja validada, especialmente em contextos críticos como agendamento médico, onde não pode haver margem para erro ou ambiguidade.

\subsection{Fundamentação Teórica e Prática}

\subsubsection{Pesquisa sobre Máquinas de Estados Finitas}
A primeira etapa do estudo consistiu em pesquisar e compreender o conceito de FSM aplicado a chatbots. Estudei como traduzir processos de negócio em diagramas de estados, identificando:

\begin{itemize}
    \item \textbf{Estados (Pages):} Representam cada etapa do fluxo conversacional (ex: coleta de especialidade, data, horário).
    \item \textbf{Transições (Routes):} Condições que permitem a mudança de um estado para outro.
    \item \textbf{Validações:} Regras que garantem a integridade dos dados coletados antes de prosseguir.
\end{itemize}

\subsubsection{Estudo de Processamento de Linguagem Natural}
Aprofundei o conhecimento sobre como sistemas de NLP interpretam linguagem humana através de:

\textbf{Intents (Intenções):} Estudei como treinar o modelo para reconhecer diferentes formas de expressar a mesma intenção. Por exemplo, as frases abaixo representam a mesma intenção de agendamento:

\begin{lstlisting}[language=text, caption={Variações Linguísticas para Treinamento de Intent}]
"Quero marcar um cardiologista"
"Preciso de uma consulta para amanha"
"Tem vaga para doutor Paulo?"
"Gostaria de agendar um horario"
"Quero consulta com dermatologista"
\end{lstlisting}

\textbf{Entidades (Entities):} Compreendi como o sistema extrai informações específicas de frases em linguagem natural. Exemplo de análise:

Entrada do usuário: \textit{"Quero ir na unidade Centro na sexta-feira"}

Extração automática:
\begin{itemize}
    \item \texttt{@unidade}: "Centro" (entidade customizada)
    \item \texttt{@sys.date}: "2024-11-29" (entidade de sistema que converte expressões temporais)
\end{itemize}

\subsubsection{Aplicação Prática: Modelagem de Fluxo de Agendamento}
Com base nos estudos teóricos, modelei um fluxo conversacional completo aplicando o conceito de Slot Filling (preenchimento obrigatório de campos):

\begin{enumerate}
    \item \textbf{Estado "Início":} Captura a especialidade médica desejada.
    \item \textbf{Estado "Coleta de Unidade":} Permanece em loop até que o parâmetro \texttt{\$session.params.unidade} seja preenchido.
    \item \textbf{Estado "Coleta de Data":} Valida se a data informada é futura e está dentro do período permitido (30 dias).
    \item \textbf{Estado "Coleta de Horário":} Apresenta opções de horários disponíveis.
    \item \textbf{Estado "Confirmação":} Exibe resumo completo para validação do usuário.
    \item \textbf{Estado "Finalização":} Processa o agendamento e gera protocolo.
\end{enumerate}

\subsubsection{Estudo de Lógica Condicional em Fluxos Conversacionais}
Pesquisei como implementar rotas condicionais para controlar transições entre estados:

\begin{lstlisting}[language=text, caption={Exemplo de Lógica Condicional Estudada}]
SE $session.params.confirmacao = "sim" ENTAO
    Transitar para Estado "Finalizacao"

SE $session.params.confirmacao = "nao" ENTAO
    Limpar todos os parametros
    Retornar para Estado "Inicio"
\end{lstlisting}

\subsubsection{Análise de Estratégias de Tratamento de Erros}
Estudei técnicas para tornar sistemas conversacionais mais robustos:

\begin{itemize}
    \item \textbf{Validação Contextual:} Aprendi a implementar validações que consideram o contexto (ex: rejeitar datas passadas com mensagens explicativas).
    \item \textbf{Fallback Progressivo:} Pesquisei estratégias de degradação gradual, onde após múltiplas falhas de compreensão, o sistema oferece alternativas (ex: transferência para atendimento humano).
    \item \textbf{Princípio Fail-Safe:} Estudei a importância de confirmações explícitas em processos críticos, onde o usuário revisa todas as informações antes da execução final.
\end{itemize}

\subsubsection{Metodologia de Validação de Sistemas Conversacionais}
Como parte do estudo, pesquisei metodologias de teste para chatbots, resultando na elaboração de cenários de validação conforme a Tabela \ref{tab:testes_dialogflow}.

\begin{table}[h!]
    \centering
    \caption{Cenários de Teste Estudados para Validação de Chatbots}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{Cenário de Teste} & \textbf{Comportamento Esperado (Aprendizado)} \\ \hline
        Fluxo completo com dados válidos & Compreender o caminho feliz e geração de confirmações. \\ \hline
        Tentativa de entrada inválida (data passada) & Estudar validações contextuais e mensagens de erro amigáveis. \\ \hline
        Usuário fornece informações incompletas & Analisar o comportamento de Slot Filling e persistência de estado. \\ \hline
        Usuário desiste durante o processo & Compreender estratégias de cancelamento e limpeza de sessão. \\ \hline
        Teste de fallback após múltiplas falhas & Estudar degradação gradual e transferência para canal alternativo. \\ \hline
        Integração com sistemas externos & Pesquisar comunicação via webhooks e tratamento de latência. \\ \hline
        Confirmação antes da ação crítica & Analisar padrões de UX para operações irreversíveis. \\ \hline
    \end{tabular}
    \label{tab:testes_dialogflow}
    \vspace{0.3em}
    \noindent{\small Fonte: Do próprio autor}
\end{table}

\subsubsection{Competências Desenvolvidas}
Ao final deste estudo, foram desenvolvidas as seguintes competências:
\begin{itemize}
    \item Modelagem de fluxos conversacionais usando FSM
    \item Compreensão de conceitos de NLP (intents, entities, context)
    \item Design de experiências conversacionais para processos críticos
    \item Estratégias de validação e tratamento de erros em chatbots
    \item Metodologias de teste para sistemas conversacionais
\end{itemize}

\section{Estudo de Arquiteturas Híbridas: Fluxos Parcialmente Generativos (Período: 10/11 a 20/11)}

\subsection{Contextualização do Estudo}
Este estudo investigou a categoria de \textit{Partly Generative Flows}, que combina a segurança dos fluxos determinísticos com a flexibilidade da IA Generativa. A pesquisa focou no uso de \textit{Generators} para enriquecer interações sem perder o controle do fluxo principal.

\subsection{Objetivos de Aprendizado}
\textbf{Objetivo Principal:} Desenvolver competências em design de arquiteturas híbridas que utilizam \textit{Generators} e \textit{Generative Fallback} estrategicamente.

O estudo explorou como tomar decisões arquiteturais baseadas em análise de risco: operações financeiras exigem fluxos rígidos e auditáveis, enquanto consultas informativas podem aproveitar a flexibilidade da IA generativa.

\subsection{Fundamentação Teórica e Prática}

\subsubsection{Pesquisa sobre Matriz de Decisão por Risco}
Estudei metodologias para classificar funcionalidades por nível de risco e determinar qual paradigma aplicar em cada caso:

\begin{table}[h!]
    \centering
    \caption{Matriz de Decisão: Paradigma por Nível de Risco}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Funcionalidade} & \textbf{Nível de Risco} & \textbf{Paradigma Adotado} \\ \hline
        Transferência PIX & Alto (Transacional) & Determinístico (Flows) \\ \hline
        Pagamento de Boleto & Alto (Transacional) & Determinístico (Flows) \\ \hline
        Consulta de Saldo & Médio (Informacional) & Determinístico (API Direta) \\ \hline
        Explicação de Termos Financeiros & Baixo (Educacional) & Generativo (Playbooks) \\ \hline
        Sugestões de Investimento & Médio (Consultivo) & Híbrido (Generators) \\ \hline
    \end{tabular}
    \vspace{0.3em}
    \noindent{\small Fonte: Do próprio autor}
\end{table}

\subsubsection{Implementação do Fluxo Determinístico (PIX)}
Para operações de alto risco, implementei um fluxo rígido e sequencial usando \textit{Deterministic Flows}:

\begin{enumerate}
    \item \textbf{Coleta de Chave PIX:} Validação de formato (CPF, e-mail, telefone, chave aleatória).
    \item \textbf{Coleta de Valor:} Validação de saldo disponível via webhook.
    \item \textbf{Autenticação:} Solicitação de senha ou biometria (integração com sistema de segurança).
    \item \textbf{Confirmação:} Exibição de resumo completo da transação.
    \item \textbf{Execução:} Chamada ao webhook para efetivar a transferência.
    \item \textbf{Comprovante:} Geração e envio do comprovante em PDF.
\end{enumerate}

Cada etapa possui validação rigorosa e não permite saltos, garantindo auditabilidade e conformidade regulatória.

\subsubsection{Implementação do Fluxo Generativo (Explicações)}
Para consultas de baixo risco, integrei o Vertex AI para gerar respostas contextualizadas:

\textbf{Exemplo de Interação:}

\textit{Usuário:} "O que é esse CDB que apareceu na minha conta?"

\textit{Sistema:} Detecta a intent \texttt{explicar\_termo\_financeiro} e extrai a entidade \texttt{@termo}: "CDB".

\textbf{Prompt Engineering para o Vertex AI:}

\begin{lstlisting}[language=text, caption={Template de Prompt para Explicações Financeiras}]
Você é um assistente bancario educado e didatico.
Explique o termo financeiro "{termo}" de forma clara e acessivel.
Use uma linguagem simples, evite jargoes tecnicos.
Limite a resposta a 3 paragrafos.
Contexto do usuario: Cliente pessoa fisica com conta corrente.

Termo: {CDB}
\end{lstlisting}

\textit{Resposta Gerada:} "CDB significa Certificado de Depósito Bancário. É uma forma de investimento onde você empresta dinheiro ao banco por um período determinado, e em troca, recebe juros. É considerado um investimento seguro, pois é garantido pelo FGC (Fundo Garantidor de Créditos) até R\$ 250 mil por CPF e instituição."

\subsubsection{Implementação do Hand-off Híbrido}
A praticidade do sistema híbrido está na transição inteligente entre paradigmas.

\textbf{Cenário:} Usuário diz: \textit{"Explica o CDB e investe 100 reais nele"}.

\textbf{Processamento:}

\begin{enumerate}
    \item O Dialogflow CX detecta duas intenções na mesma frase: \texttt{explicar\_termo} e \texttt{investir}.
    \item \textbf{Primeira Ação (Generativa):} O Vertex AI gera a explicação sobre CDB.
    \item \textbf{Transição (Hand-off):} Após a explicação, o sistema detecta a intenção de investimento e faz a transição para o fluxo determinístico.
    \item \textbf{Segunda Ação (Determinística):} O fluxo de investimento é iniciado, solicitando confirmação do valor (R\$ 100), prazo desejado e senha de autorização.
\end{enumerate}

Esta arquitetura combina a flexibilidade da IA generativa com a segurança de fluxos transacionais auditáveis.

\subsubsection{Competências Desenvolvidas}
Ao final deste estudo, foram desenvolvidas as seguintes competências:
\begin{itemize}
    \item Análise de risco aplicada a decisões arquiteturais
    \item Design de sistemas híbridos com segregação de responsabilidades
    \item Compreensão de fluxos determinísticos para operações críticas
    \item Aplicação de IA generativa em contextos de baixo risco
    \item Técnicas de prompt engineering para modelos de linguagem
    \item Estratégias de hand-off entre paradigmas distintos
\end{itemize}

\section{Estudo de Arquitetura Serverless com GCP Cloud Functions (Período: 15/11 a 25/11)}

\subsection{Contextualização do Estudo}
Este estudo focou em compreender o paradigma de computação serverless e sua aplicação em integrações de sistemas. A pesquisa envolveu o aprendizado de webhooks, Cloud Functions e padrões de integração entre sistemas conversacionais e APIs legadas.

\subsection{Objetivos de Aprendizado}
\textbf{Objetivo Principal:} Desenvolver competências em design e implementação de backends serverless para integração de sistemas heterogêneos.

O estudo explorou como webhooks atuam como ponte entre camadas conversacionais (Dialogflow) e APIs internas, executando lógica de negócio e consultas a bancos de dados de forma escalável e eficiente.

\subsection{Fundamentação Teórica e Prática}

\subsubsection{Pesquisa sobre Padrão API Gateway}
Estudei o padrão arquitetural API Gateway e como Cloud Functions podem atuar como orquestradores:

\begin{itemize}
    \item \textbf{Entrada:} Requisição HTTP POST do Agente contendo os parâmetros da sessão.
    \item \textbf{Processamento:} Lógica de negócio e chamadas a APIs internas (REST).
    \item \textbf{Saída:} Resposta formatada no protocolo do Agente (JSON estruturado).
\end{itemize}

\subsubsection{Implementação do Webhook de Rastreamento}
Para o caso de uso de rastreamento de encomendas em um sistema de logística, implementei a seguinte Cloud Function:

\begin{lstlisting}[language=JavaScript, caption={Webhook para Rastreamento de Encomendas (Node.js)}]
const axios = require('axios');

exports.dialogflowWebhook = async (req, res) => {
  try {
    // 1. Extrair parametros enviados pelo Dialogflow
    const trackingCode = req.body.sessionInfo.parameters.codigo_rastreio;
    
    // 2. Validacao de entrada
    if (!trackingCode || trackingCode.length < 8) {
      return res.json({
        fulfillmentResponse: {
          messages: [{
            text: { 
              text: ['Codigo de rastreio invalido. Por favor, informe um codigo valido.'] 
            }
          }]
        }
      });
    }

    // 3. Logica de Negocio: Consultar API da Transportadora
    const apiUrl = `https://api.transportadora.com/v1/tracking/${trackingCode}`;
    const response = await axios.get(apiUrl, {
      headers: { 'Authorization': `Bearer ${process.env.API_TOKEN}` },
      timeout: 5000 // Timeout de 5 segundos
    });

    const status = response.data;
    // Exemplo de retorno: { local: "Curitiba", previsao: "2 dias", status: "em_transito" }

    // 4. Montar a resposta para o Dialogflow
    const mensagem = `Sua encomenda ${trackingCode} esta em ${status.local}. ` +
                     `Previsao de entrega: ${status.previsao}. ` +
                     `Status: ${status.status}.`;

    return res.json({
      fulfillmentResponse: {
        messages: [{
          text: { text: [mensagem] }
        }]
      },
      // 5. Atualizar parametros da sessao (opcional)
      sessionInfo: {
        parameters: {
          ultimo_status: status.status,
          data_consulta: new Date().toISOString()
        }
      }
    });

  } catch (error) {
    // 6. Tratamento de erros
    console.error('Erro ao consultar API de rastreamento:', error.message);
    
    return res.status(500).json({
      fulfillmentResponse: {
        messages: [{
          text: { 
            text: ['Desculpe, nao foi possivel consultar o rastreamento no momento. Tente novamente em alguns instantes.'] 
          }
        }]
      }
    });
  }
};
\end{lstlisting}

\subsubsection{Boas Práticas Implementadas}

\begin{itemize}
    \item \textbf{Validação de Entrada:} Todos os parâmetros recebidos do Dialogflow são validados antes do processamento.
    \item \textbf{Timeout e Retry:} Implementei timeout de 5 segundos nas chamadas HTTP para evitar que o usuário fique esperando indefinidamente.
    \item \textbf{Tratamento de Erros:} Erros são logados (para debugging) e mensagens amigáveis são retornadas ao usuário.
    \item \textbf{Segurança:} Credenciais de API são armazenadas como variáveis de ambiente (Secret Manager do GCP), nunca no código.
    \item \textbf{Logging:} Utilizei o Cloud Logging para rastreabilidade e debugging em produção.
\end{itemize}

\subsubsection{Deploy e Configuração no GCP}
O processo de deploy seguiu as melhores práticas de CI/CD:

\begin{enumerate}
    \item \textbf{Desenvolvimento Local:} Testes locais usando o Functions Framework.
    \item \textbf{Versionamento:} Código versionado no Git com tags semânticas.
    \item \textbf{Deploy:} Utilizei o comando \texttt{gcloud functions deploy} com configuração de memória (256MB) e timeout (60s).
    \item \textbf{Configuração de Trigger:} A função foi configurada para aceitar requisições HTTP autenticadas.
    \item \textbf{Integração com o Agente:} A URL da Cloud Function foi configurada no webhook do Conversational Agent.
\end{enumerate}

\subsubsection{Testes e Validação}
A validação foi realizada em múltiplas camadas, conforme evidenciado na Tabela \ref{tab:testes_webhook}.

\begin{table}[h!]
    \centering
    \caption{Testes de Validação do Webhook de Rastreamento}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{Cenário de Teste} & \textbf{Verificação (Assert)} \\ \hline
        Código de rastreamento válido & A função deve retornar o status correto da API da transportadora. \\ \hline
        Código de rastreamento inválido & A função deve retornar mensagem de erro amigável sem crashar. \\ \hline
        API da transportadora indisponível & A função deve retornar mensagem de erro após timeout e logar o erro. \\ \hline
        Teste de carga (100 req/s) & A Cloud Function deve escalar automaticamente sem degradação de performance. \\ \hline
        Validação de segurança & Requisições sem token de autenticação devem ser rejeitadas (HTTP 401). \\ \hline
        Teste de latência & O tempo de resposta total (Dialogflow + Webhook + API) deve ser inferior a 3 segundos. \\ \hline
    \end{tabular}
    \label{tab:testes_webhook}
    \vspace{0.3em}
    \noindent{\small Fonte: Do próprio autor}
\end{table}

\subsubsection{Competências Desenvolvidas}
Ao final deste estudo, foram desenvolvidas as seguintes competências:
\begin{itemize}
    \item Compreensão do paradigma de computação serverless
    \item Design e implementação de webhooks para integração de sistemas
    \item Aplicação do padrão API Gateway em arquiteturas distribuídas
    \item Tratamento de erros e validação de entrada em APIs
    \item Configuração e deploy de Cloud Functions no GCP
    \item Boas práticas de segurança (Secret Manager, autenticação)
    \item Metodologias de teste para integrações assíncronas
\end{itemize}

\section{Estudo de RAG com Data Stores e Vertex AI (Período: 20/11 a 24/11)}

\subsection{Contextualização do Estudo}
Este estudo pincelou o conhecimento sobre a implementação de RAG (Retrieval-Augmented Generation) utilizando a abstração de \textit{Data Stores} do ecossistema Conversational Agents. A pesquisa focou em como conectar agentes a fontes de dados não estruturadas (PDFs, sites) de forma nativa.

\subsection{Objetivos de Aprendizado}
\textbf{Objetivo Principal:} Desenvolver competências em configuração de \textit{Data Stores}, ingestão de documentos e integração com modelos generativos para respostas fundamentadas.

O estudo explorou o desafio de criar assistentes capazes de responder perguntas sobre documentos extensos (ex: manual de 50 páginas) de forma precisa e contextualizada, mantendo citações às fontes originais.

\subsection{Fundamentação Teórica e Prática}

\subsubsection{Pesquisa sobre Arquitetura RAG}
Estudei o padrão arquitetural RAG e suas etapas fundamentais:

\begin{enumerate}
    \item \textbf{Ingestão de Documentos:} Upload do PDF "Normas da Empresa 2024" para o Vertex AI Search.
    \item \textbf{Chunking e Indexação:} O documento é dividido em chunks semânticos e indexado com embeddings vetoriais.
    \item \textbf{Retrieval (Busca):} Quando o usuário faz uma pergunta, o sistema busca os chunks mais relevantes usando similaridade vetorial.
    \item \textbf{Augmentation (Aumento):} Os chunks recuperados são injetados no contexto do prompt do modelo generativo.
    \item \textbf{Generation (Geração):} O modelo (Gemini Pro) gera a resposta baseada no contexto recuperado.
\end{enumerate}


\section{Estudo de Protocolos e Kits de Desenvolvimento para Agentes: ADK e MCP (Período: 10/12 a 20/12)}

\subsection{Contextualização do Estudo}
A evolução dos chatbots para agentes autônomos exigiu o estudo de novos padrões de interoperabilidade e desenvolvimento. Este estudo focou em duas tecnologias emergentes: o \textit{Agent Development Kit} (ADK) para construção de agentes complexos e o \textit{Model Context Protocol} (MCP) para padronização da conexão entre modelos de IA e fontes de dados externas.

\subsection{Objetivos de Aprendizado}
\textbf{Objetivo Principal:} Compreender e implementar padrões modernos de arquitetura de agentes, focando na interoperabilidade e na capacidade de uso de ferramentas (tool use).

O estudo buscou superar as limitações de integrações ad-hoc (como webhooks rígidos) explorando o protocolo MCP, que permite que assistentes de IA descubram e utilizem recursos de forma dinâmica e padronizada.

\subsection{Fundamentação Teórica e Prática}

\subsubsection{Pesquisa sobre Model Context Protocol (MCP)}
Estudei a especificação do protocolo MCP, que define uma arquitetura cliente-servidor para conectar IAs a sistemas:

\begin{itemize}
    \item \textbf{MCP Hosts:} Aplicações que "consomem" o contexto (ex: IDEs, Chatbots).
    \item \textbf{MCP Servers:} Serviços que expõem recursos, prompts e ferramentas.
    \item \textbf{MCP Clients:} O conector que mantém a sessão entre Host e Server.
\end{itemize}

A principal vantagem identificada foi a dissociação: um único servidor MCP (ex: "Conector Google Drive") pode ser reutilizado por múltiplos agentes sem reescrita de código.

\subsubsection{Implementação de um Servidor MCP Simples}
Para fixar o aprendizado, desenvolvi um servidor MCP em TypeScript que expõe uma base de dados local de produtos para um agente.

\begin{lstlisting}[language=JavaScript, caption={Implementação de Servidor MCP (TypeScript)}]
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";

// 1. Inicializacao do Servidor
const server = new Server(
  { name: "estoque-server", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

// 2. Definicao da Ferramenta (Tool)
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [{
      name: "consultar_estoque",
      description: "Consulta a quantidade disponivel de um produto pelo ID",
      inputSchema: {
        type: "object",
        properties: {
          produtoId: { type: "string" }
        },
        required: ["produtoId"]
      }
    }]
  };
});

// 3. Execucao da Ferramenta
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === "consultar_estoque") {
    const { produtoId } = request.params.arguments;
    // Simulacao de consulta ao banco
    const estoque = db.find(p => p.id === produtoId)?.qtd || 0;
    
    return {
      content: [{
        type: "text",
        text: `O produto ${produtoId} possui ${estoque} unidades.`
      }]
    };
  }
  throw new Error("Ferramenta nao encontrada");
});

// 4. Conexao via Stdio
const transport = new StdioServerTransport();
await server.connect(transport);
\end{lstlisting}

\subsubsection{Estudo de Agent Development Kit (ADK)}
Explorei frameworks e kits de desenvolvimento (ADK) que facilitam a orquestração de agentes. O foco foi entender como esses kits abstraem a complexidade de:

\begin{itemize}
    \item \textbf{Gerenciamento de Memória:} Como o agente "lembra" de interações passadas.
    \item \textbf{Planejamento (Planning):} Capacidade do agente de quebrar uma tarefa complexa ("Planejar viagem") em sub-tarefas ("Ver voos", "Reservar hotel").
    \item \textbf{Execução de Ferramentas:} O uso autônomo de ferramentas expostas via MCP ou APIs.
\end{itemize}

\subsubsection{Comparativo: Webhooks Tradicionais vs. MCP}
Realizei uma análise comparativa para entender a evolução arquitetural:

\begin{table}[h!]
    \centering
    \caption{Comparativo: Integração via Webhook vs. MCP}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Característica} & \textbf{Webhook (Tradicional)} & \textbf{Protocolo MCP} \\ \hline
        Acoplamento & Alto (definido no design time) & Baixo (descoberta dinâmica) \\ \hline
        Reusabilidade & Baixa (específico para um fluxo) & Alta (reusável por vários agentes) \\ \hline
        Flexibilidade & Rígida (entrada/saída fixa) & Flexível (modelo decide como usar) \\ \hline
        Manutenção & Complexa (alterar em 2 pontas) & Simples (alterar apenas no server) \\ \hline
    \end{tabular}
    \vspace{0.3em}
    \noindent{\small Fonte: Do próprio autor}
\end{table}

\subsubsection{Competências Desenvolvidas}
Ao final deste estudo, foram desenvolvidas as seguintes competências:
\begin{itemize}
    \item Compreensão da arquitetura de Agentes Autônomos
    \item Implementação de servidores compatíveis com o padrão MCP
    \item Desenvolvimento de ferramentas (Tools) para consumo por LLMs
    \item Análise de trade-offs entre integrações estáticas e dinâmicas
    \item Uso de SDKs para orquestração de agentes (ADK)
    \item Debugging de comunicação via transporte stdio/SSE
\end{itemize}
