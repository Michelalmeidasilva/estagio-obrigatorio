\section{Migração de Arquitetura Bridge para JSI, Fabric e Turbo Module da biblioteca de (Período: 16/10 a 31/10)}

A tarefa consistiu na correção de uma breaking change crítica, introduzida após a atualização de versão do React Native. A mudança exigiu a refatoração de uma biblioteca interna, com modificações diretas no código nativo (Android/iOS) para adequação à Nova Arquitetura (JSI/Turbo Modules).

Para um diagnóstico preciso da falha, foi realizada uma pesquisa aprofundada em fontes técnicas, incluindo a documentação oficial (GitHub do React Native), consultas no Stack Overflow e o uso de ferramentas de assistência de código (Cursor AI).

O principal desafio metodológico foi o ciclo de feedback (build/test cycle) do projeto principal, que consumia aproximadamente 40 minutos por alteração. Esse overhead tornava a depuração Iterativa impraticável e arriscada.

Para mitigar esse risco e aumentar a agilidade, foi adotada a estratégia de desenvolvimento em ambiente isolado (Sandboxing). A correção foi implementada e validada em um aplicativo de demonstração ("sample app") minimalista, permitindo ciclos rápidos de desenvolvimento e depuração antes da integração.

O processo seguiu um pipeline de engenharia de software estruturado, desde o desenvolvimento local até a produção, conforme detalhado nas etapas abaixo.

\subsection{Desenho da solução}

A Figura \ref{fig:comunicacao_jsi} ilustra o processo de criação de um componente e as funções que possibilitam a comunicação entre o código React Native e os módulos nativos.

\begin{figure}[h!]
    \centering
    % \includegraphics[width=\textwidth]{figura1.png} % Placeholder para a imagem
    \caption{Comunicação JSI entre React-native e Nativo.}
    \label{fig:comunicacao_jsi}
    \source{Fonte: Do próprio autor.}
\end{figure}

\subsection{Desenvolvimento}
O desenvolvimento foi separado entre duas implementações: a Implementação A utilizando a arquitetura legada por bridge e a Implementação B com a nova arquitetura após a migração. O exemplo utilizado será um simples print da mensagem "Olá mundo".

\subsubsection{Implementação A - Arquitetura Legada}

A implementação abaixo utiliza a arquitetura legada, empregando o módulo NativeModules. Na camada JavaScript da aplicação, a comunicação com o módulo nativo é estabelecida por meio da importação de NativeModules do pacote react-native.

\begin{lstlisting}[language=JavaScript, caption={App.js (Lado JS)}]
import React from 'react';
import { Button, View, NativeModules } from 'react-native';

const { HelloWorldModule } = NativeModules;

const App = () => {
  const handlePressLegacy = async () => {
    try {
      const saudacao = await HelloWorldModule.getHelloWorld();
      
      console.log(saudacao); // Imprime "Olá mundo (Legado via Bridge)"
    
    } catch (e) {
      console.error(e);
    }
  };

  return (
    <View style={{ flex: 1, justifyContent: 'center' }}>
      <Button
        title="Testar Bridge Legada"
        onPress={handlePressLegacy}
      />
    </View>
  );
};

export default App;
\end{lstlisting}

No Código Nativo (Android - Java) foi realizada a implementação de um método chamado getHelloWorld para o retorno de uma string simples e um método getName para o retorno do nome do módulo nativo, sendo implementada da seguinte maneira:

\begin{lstlisting}[language=Java, caption={HelloWorldModule.java}]
// /android/app/src/main/java/.../HelloWorldModule.java
package com.meuapp;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.Promise;

public class HelloWorldModule extends ReactContextBaseJavaModule {

    public HelloWorldModule(ReactApplicationContext context) {
        super(context);
    }

    @Override
    public String getName() {
        return "HelloWorldModule"; // Nome usado no JS
    }

    // Método exposto para o JS
    @ReactMethod
    public void getHelloWorld(Promise promise) {
        // A ponte é assíncrona, então usamos Promise
        promise.resolve("Olá mundo (Legado via Bridge)");
    }
}
\end{lstlisting}

No código nativo (iOS - Objective-C), análogo ao código em Java, a implementação foi realizada através de:

\begin{lstlisting}[language=C++, caption={HelloWorldModule (Objective-C)}]
// HelloWorldModule.h
#import <React/RCTBridgeModule.h>
// O módulo deve implementar o protocolo <RCTBridgeModule>
@interface HelloWorldModule : NSObject <RCTBridgeModule>
@end

// HelloWorldModule.m
#import "HelloWorldModule.h"
@implementation HelloWorldModule
// Expõe o módulo para o JS com o nome "HelloWorldModule"
RCT_EXPORT_MODULE(HelloWorldModule);
// Expõe o método getHelloWorld para o JS
// A chamada é assíncrona e usa Promises
RCT_EXPORT_METHOD(getHelloWorld: (RCTPromiseResolveBlock)resolve
                  rejecter: (RCTPromiseRejectBlock)reject)  {
    NSString *saudacao = @"Olá mundo (Legado via Bridge)";
    if (saudacao) {
        resolve(saudacao);
    } else {
        reject(@"error", @"Não foi possível gerar a saudação", nil);
    }
}
@end
\end{lstlisting}

\textbf{Funcionamento da Bridge:}
\begin{itemize}
    \item \textbf{Chamada JS:} O JavaScript chamava HelloWorldModule.getHelloWorld()
    \item \textbf{Serialização:} O React Native serializava o nome do módulo (HelloWorldModule) e o nome do método (getHelloWorld) em uma mensagem JSON
    \item \textbf{Comunicação:} A mensagem JSON era enviada da thread JavaScript para a thread Nativa, atravessando a Bridge
    \item \textbf{Processamento:} A thread Nativa desserializava a mensagem JSON, encontrava a classe HelloWorldModule e chamava o método correspondente
    \item \textbf{Retorno:} O resultado era serializado e retornado via callback/promise para o JavaScript
\end{itemize}

\subsubsection{Implementação B - Nova arquitetura}
No exemplo de implementação do logMessage com TurboModule, a migração demandou um arquivo de especificação (Spec) em TypeScript para definição da API, o qual serviu de base para geração do código boilerplate nativo.

\textbf{Definição da API (Spec - TypeScript)}

Um arquivo de especificação define o contrato da API de forma explícita na camada javascript, da seguinte maneira:

\begin{lstlisting}[language=TypeScript, caption={NativeHelloWorld.ts (Spec)}]
// /js/NativeHelloWorld.ts (A "Spec")
import type { TurboModule } from 'react-native/Libraries/TurboModule/TurboModule';
import { TurboModuleRegistry } from 'react-native';

// 1. Definimos a interface
export interface Spec extends TurboModule {
  // 2. Definimos um método SÍNCRONO
  getHelloWorld(): string; 
}

// 3. Registramos o módulo (o nome 'RTNHelloWorld' é o nome oficial do componente)
export default TurboModuleRegistry.getEnforcing<Spec>(
  'RTNHelloWorld',
);
\end{lstlisting}

\textbf{Implementação Nativa (Android - Kotlin)}

Na implementação nativa, foi utilizada uma interface gerada que permitiu o acesso direto ao runtime JavaScript.

\begin{lstlisting}[language=Java, caption={RTNHelloWorldModule.java}]
// /android/app/src/main/java/.../RTNHelloWorldModule.java
package com.meuapp;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactMethod;
import androidx.annotation.NonNull;

// 1. O Codegen gera 'NativeHelloWorldSpec'
import com.facebook.fbreact.specs.NativeHelloWorldSpec; 

// 2. Implementamos a Spec gerada
public class RTNHelloWorldModule extends NativeHelloWorldSpec {

    public static final String NAME = "RTNHelloWorld";

    public RTNHelloWorldModule(ReactApplicationContext context) {
        super(context);
    }

    @Override
    @NonNull
    public String getName() {
        return NAME;
    }

    // 3. Implementação SÍNCRONA!
    //    Sem 'Promise', o retorno é direto.
    @Override
    public String getHelloWorld() {
        return "Olá mundo (Nova Arquitetura via JSI)";
    }
}
\end{lstlisting}

\textbf{Código em JavaScript}

A interface de uso no JavaScript conservou estrutura similar, mas passou a acessar diretamente o módulo C++ por meio da JSI.

\begin{lstlisting}[language=JavaScript, caption={App.js (Lado JS com Nova Arquitetura)}]
// App.js (Lado JS)
import React from 'react';
import { Button, View } from 'react-native';

// 1. Importa diretamente o módulo (conforme a Spec)
import RTNHelloWorld from './js/NativeHelloWorld'; 

const App = () => {

  const handlePressNewArch = () => {
    // 2. A chamada é SÍNCRONA!
    //    - Sem async/await, sem .then()
    //    - A JSI permite a chamada direta
    const saudacao = RTNHelloWorld.getHelloWorld();
    
    console.log(saudacao); // Imprime "Olá mundo (Nova Arquitetura via JSI)"
  };

  return (
    <View style={{ flex: 1, justifyContent: 'center' }}>
      <Button
        title="Testar Nova Arquitetura"
        onPress={handlePressNewArch}
      />
    </View>
  );
};

export default App;
\end{lstlisting}

\textbf{Implementação Nativa (iOS - Objective-C)}

Para a plataforma iOS, implementou-se o código nativo em Objective-C.

\begin{lstlisting}[language=C++, caption={RTNHelloWorld (Objective-C)}]
// RTNHelloWorld.h
// 1. Importa a Spec gerada pelo Codegen (baseada no seu .ts)
#import <RTNHelloWorld/RTNHelloWorldSpec.h> 

// 2. O nome da classe deve corresponder ao que o JS espera (RTNHelloWorld)
// 3. A classe implementa o protocolo da Spec gerada
@interface RTNHelloWorld : NSObject <NativeHelloWorldSpec> 
@end

// RTNHelloWorld.mm
#import "RTNHelloWorld.h"

@implementation RTNHelloWorld

// 1. Exporta o módulo (o nome é o da classe)
RCT_EXPORT_MODULE(RTNHelloWorld)

// 2. Esta é a implementação SÍNCRONA da Spec
- (NSString *)getHelloWorld
{
    // O retorno é direto, sem Promises, sem Bridge
    return @"Olá mundo (Nova Arquitetura via JSI)";
}

/*
   NOTA: O Codegen e o template de TurboModule cuidam de
   todo o "encanamento" C++ (JSI) para que este método
   possa ser chamado diretamente pelo JavaScript.
*/

@end
\end{lstlisting}

A nova arquitetura do React Native substituiu o sistema antigo de comunicação entre JavaScript e código nativo. No lugar da bridge assíncrona que funcionava como um intermediário lento, neste novo formato tem-se uma conexão direta e síncrona. Esta arquitetura tem três componentes principais: primeiro, o JSI que permite ao JavaScript chamar funções nativas diretamente, sem serialização de dados. Segundo, o TurboModules que gerencia essa comunicação de forma eficiente. E terceiro, o Codegen que automaticamente gerou todo o código de conexão necessário. A vantagem neste formato é que tudo acontece de forma síncrona. Não há espera por callbacks ou promises - as chamadas são instantâneas. Isso tornou a aplicação significativamente mais rápida e responsiva.

\subsection{Execução do módulo em um projeto de demonstração}
Esta etapa foi a aplicação direta da estratégia de mitigação de risco para contornar o build de 40 minutos do projeto principal.

\textbf{Descrição:} Um aplicativo React Native mínimo ("sample app") foi criado e configurado. O objetivo deste ambiente foi isolar totalmente a biblioteca do restante do ecossistema complexo do projeto principal.

\textbf{Execução:} A biblioteca modificada foi vinculada localmente a este projeto de demonstração (utilizando yarn link ou referência de diretório no package.json).

\textbf{Validação:} Esta abordagem permitiu ciclos de feedback quase instantâneos. Foi possível validar rapidamente:
\begin{itemize}
    \item A correta compilação do código nativo (Kotlin/Swift).
    \item A vinculação bem-sucedida do TurboModule através da JSI.
    \item A execução da funcionalidade central, confirmando que a comunicação entre a camada JavaScript e as novas implementações nativas estava ocorrendo conforme a especificação da API.
\end{itemize}

\subsection{Publicação de nova versão da biblioteca}
Após a validação funcional no ambiente isolado, a biblioteca precisou ser disponibilizada para consumo pelo projeto principal.

\textbf{Descrição:} O processo de empacotamento e versionamento da biblioteca para distribuição interna.

\textbf{Execução:} O processo seguiu o Versionamento Semântico (SemVer), onde a versão do pacote foi incrementada.

\textbf{Processo:} O build de distribuição da biblioteca foi gerado (compilando o TypeScript e preparando os artefatos nativos via react-native-builder-bob). O pacote foi então publicado em um registro de pacotes privados (NPM privado), garantindo que a nova versão estivesse acessível para o pipeline de CI/CD do aplicativo principal.

\subsection{Testes em ambiente de homologação (QA)}
Este foi o primeiro nível de integração real, onde a correção encontrou o ecossistema completo do aplicativo.

\textbf{Descrição:} O ambiente de homologação (QA) simula a infraestrutura de produção, mas com dados controlados e isolados, destinado à validação pela equipe de Qualidade.

\textbf{Execução:} O aplicativo principal foi atualizado para consumir a nova versão da biblioteca recém-publicada. Um novo build do aplicativo foi gerado e distribuído para a equipe de QA.

\textbf{Validação:} A equipe de QA executou um plano de testes de regressão completo, focado não apenas na funcionalidade corrigida, mas também em áreas adjacentes. O objetivo foi garantir que (A) a correção funcionava conforme o esperado dentro do app complexo e (B) a atualização não introduziu efeitos colaterais (regressões) em outras partes do sistema.

\subsection{Testes em ambientes pré-produtivos (UAT/Staging)}
Esta etapa representou o "ensaio geral" antes da produção.

\textbf{Descrição:} O ambiente de Pré-Produção (ou Staging) é um espelho fiel do ambiente de Produção, utilizando a mesma infraestrutura e, idealmente, uma réplica recente (e anonimizada) do banco de dados produtivo.

\textbf{Execução:} O build aprovado em Homologação (QA) foi promovido para este ambiente.

\textbf{Validação:} Aqui ocorreu a validação final de aceitação (UAT - User Acceptance Testing) por parte dos stakeholders ou Product Owners. Além dos testes funcionais, foram avaliados aspectos não-funcionais, como a performance da comunicação JSI sob carga e a interação com serviços de backend reais. Esta foi a última verificação de segurança antes da exposição aos usuários finais.

\subsection{Deploy para ambiente produtivo}
A etapa final do pipeline, disponibilizando a correção para todos os usuários.

\textbf{Descrição:} O processo de lançamento da versão do aplicativo contendo a biblioteca atualizada para o público geral.

\textbf{Execução:} Seguindo as melhores práticas de Entrega Contínua (CD), o deploy foi realizado através de um lançamento em fases (Staged Rollout).

\textbf{Metodologia:} A nova versão foi liberada inicialmente para uma pequena porcentagem de usuários (ex: 1\%, depois 5\%, 10\%). Durante esse processo, a equipe monitorou ativamente os dashboards de performance e estabilidade (APM, Crashlytics) para identificar qualquer anomalia ou erro em tempo real. Com a confirmação da estabilidade, a distribuição foi gradualmente aumentada até atingir 100\% da base de usuários.

\section{Migração do react-native 0.71.5 para a 0.81.4 (Período: 16/10 a 31/10)}

O módulo nativo, empacotado originalmente com o react-native-builder-bob, tornou-se obsoleto e causava erro de renderização dos componentes de layout após o upgrade do React Native. Utilizando o boilerplate e as ferramentas de linking do react-native-builder-bob, foram reconfigurados os wrappers nativos. Este processo exigiu a criação de um arquivo de especificação TypeScript (.d.ts), que define formalmente a interface do módulo, garantindo a tipagem estática. Em seguida, foi adaptado os entry points nativos (em Kotlin para Android e Swift para iOS) para implementar a interface gerada pelo JSI, o que assegurou a comunicação síncrona, tipada e de alta performance entre o JavaScript e o código nativo. O upgrade do React Native da versão 0.71.5 para a 0.81.4 envolveu diversas mudanças estruturais, de dependências e de configuração. Abaixo está um resumo das principais alterações realizadas, conforme o relatório do Upgrade Helper.

\subsection{Desenvolvimento}

\begin{table}[h!]
    \centering
    \caption{Mudanças de Versão e Dependências}
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Item} & \textbf{Versão Anterior (0.71.5)} & \textbf{Versão Atualizada (0.81.4)} \\ \hline
    React Native & 0.71.5 & 0.81.4 \\ \hline
    React & 18.2.0 & 19.1.0 \\ \hline
    Node.js (Engine) & Não especificado & >=20 (Mínimo exigido) \\ \hline
    TypeScript & 4.8.4 & \textasciicircum5.8.3 \\ \hline
    react-test-renderer & 18.2.0 & 19.1.0 \\ \hline
    Jest & \textasciicircum29.2.1 & \textasciicircum29.6.3 \\ \hline
    Prettier & \textasciicircum2.4.1 & 2.8.8 \\ \hline
    \end{tabular}
    \source{Fonte: Do próprio autor.}
\end{table}

Houve também a adição de novas dependências de desenvolvimento, como:
\begin{itemize}
    \item Inclusão dos pacotes CLI da comunidade na versão 20.0.0 (@react-native-community/cli, cli-platform-android, cli-platform-ios).
    \item Inclusão de novos presets e configurações específicas do React Native: @react-native/babel-preset, @react-native/eslint-config, @react-native/metro-config, e @react-native/typescript-config, todos na versão 0.81.48.
    \item Remoção de pacotes antigos como @react-native-community/eslint-config e @tsconfig/react-native.
    \item O arquivo .node-version foi deletado.
\end{itemize}

\subsubsection{Destaques das Mudanças de Versões Intermediárias}
O upgrade passou por versões que introduziram mudanças significativas:

\begin{table}[h!]
    \centering
    \caption{Principais mudanças na atualização do RN.}
    \begin{tabular}{|l|p{10cm}|}
    \hline
    \textbf{Versão} & \textbf{Principais Mudanças} \\ \hline
    0.77 & Alterar o template do AppDelegate de Obj-C++ para Swift. Se for mantido o AppDelegate.mm, é necessário adicionar a linha RCTAppDependencyProvider. \\ \hline
    0.74 & Inclui Yoga 3.0 e o modo Bridgeless por padrão na Nova Arquitetura. O SDK Mínimo do Android agora é 23 (Android 6.0). Adiciona suporte a Yarn 3, e remove PropTypes previamente depreciados. \\ \hline
    0.73 & Inclui um processo atualizado para o Manifesto de Privacidade do iOS, agora obrigatório pela Apple. \\ \hline
    0.72 & Inclui uma nova configuração do Metro e um processo atualizado para o Manifesto de Privacidade do iOS. \\ \hline
    \end{tabular}
    \source{Fonte: Do próprio autor.}
\end{table}

\subsubsection{Alterações nos Arquivos de Configuração}
\begin{description}
    \item[.eslintrc.js:] O extend do ESLint foi alterado de @react-native-community para @react-native.
    \item[.gitignore:] Foram adicionadas regras para ignorar arquivos relacionados ao Kotlin (.kotlin/). Foi atualizado a regra para ignorar dependências do CocoaPods de /ios/Pods/ para **/Pods/. Foram adicionadas regras para ignorar arquivos temporários do Metro (.metro-health-check*) e diretórios do Yarn v3 (.yarn/*, .yarn/plugins, .yarn/versions, etc.).
    \item[.prettierrc.js:] Foi realizada a remoção de duas regras de formatação: bracketSameLine: true e bracketSpacing: false.
    \item[Gemfile (iOS):] Foi realizado o aumento do requisito mínimo do Ruby para >=2.6.18. Foi realizada a atualização e exclusão de versões problemáticas do cocoapods e activesupport. Foi realizado a adição de bibliotecas da Ruby Standard Library removidas no Ruby 3.4.0, como bigdecimal, logger, benchmark e mutex\_m18.
\end{description}

\subsubsection{Refatoração do Arquivo App.tsx (Tela Inicial)}
A estrutura da tela inicial padrão (App.tsx) foi completamente refatorada, migrando de uma implementação manual dos componentes do boilerplate para o uso de um novo componente dedicado:
\begin{itemize}
    \item O código foi migrado para usar SafeAreaProvider e o hook useSafeAreaInsets do pacote react-native-safe-area-contex.
    \item O conteúdo principal da tela inicial (seções "Step One", "See Your Changes", etc.) foi substituído por um único componente: <NewAppScreen />, importado de @react-native/new-app-screen.
    \item O objeto styles padrão foi simplificado, mantendo apenas o estilo de container.
\end{itemize}

\subsubsection{Ferramenta de Upgrade}
Para a gestão de dependências neste upgrade, foi utilizado a ferramenta @rnx-kit/align-deps da Microsoft, que automatiza o alinhamento de versões de pacotes compatíveis com a versão específica do React Native. O comando utilizado foi:

\begin{lstlisting}[language=bash]
npx @rnx-kit/align-deps --requirements react-native@0.81.4
\end{lstlisting}

\subsection{Publicação de nova versão da biblioteca}
Após a validação no ambiente isolado, o módulo reconfigurado foi versionado (seguindo o Versionamento Semântico) e empacotado, tornando a nova versão corrigida disponível para ser consumida pelo pipeline de CI/CD do aplicativo principal.

\subsection{Testes em ambiente de homologação (QA)}
Nesta etapa, o aplicativo principal (agora migrado para a versão 0.81.4 do React Native) teve sua dependência atualizada para a nova versão da biblioteca. Um build foi gerado e disponibilizado para a equipe de QA. O escopo dos testes foi duplo:
\begin{itemize}
    \item \textbf{Teste de Correção:} Validar especificamente que o erro de renderização do componente de layout foi resolvido.
    \item \textbf{Teste de Regressão do Upgrade:} Executar um plano de testes completo para garantir que as vastas mudanças estruturais do upgrade (como Yoga 3.0, novo AppDelegate em Swift, mudanças no App.tsx e a remoção de PropTypes) não introduziram novos bugs e regressões funcionais.
\end{itemize}

\subsection{Testes em ambientes pré-produtivos (pré-produção)}
O build aprovado pela equipe de QA foi promovido para o ambiente de Pré-Produção. Este ambiente espelha a infraestrutura de produção, incluindo a conexão com backends e serviços reais. O objetivo foi validar o comportamento do aplicativo inteiramente atualizado (RN 0.81.4 e o módulo JSI corrigido) sob condições reais. Verificou-se as funcionalidades após a troca da comunicação JSI, a estabilidade do app após as mudanças de dependências e a compatibilidade com os sistemas nativos Android e IOS.

\subsection{Deploy para ambiente produtivo}
Dada a magnitude da atualização (uma migração de versão maior do React Native e a introdução de um módulo JSI refatorado), o deploy foi realizado com cautela. Utilizou-se a estratégia de Staged Rollout (lançamento em fases) através das lojas (App Store e Play Store). A nova versão foi liberada inicialmente para um pequeno percentual da base de usuários. Durante esse período, as ferramentas de monitoramento de performance (APM) e crash reporting (Crashlytics) foram acompanhadas ativamente para validar a estabilidade do upgrade e da nova implementação JSI em cenários de uso real, antes da liberação para 100\% dos usuários.

\section{Atualização Crítica do Google SDK (v10 para v12) (Período: 16/10 a 31/10)}

A atualização da dependência do Google SDK foi obrigatória por questões de segurança e compatibilidade, mas quebrou a funcionalidade do módulo nativo devido a breaking changes de API e conflitos de dependência. A solução foi um ajuste fino e especialista nas dependências nativas:

\begin{itemize}
    \item \textbf{Android (Gradle):} Realizei a atualização explícita do build.gradle do módulo para o Google SDK v12, aplicando, quando necessário, estratégias de Gradle Resolution Strategy para forçar a nova versão e garantir a coexistência com o restante do projeto. Finalizei com um clean build para resolver eventuais conflitos de recursos.
    \item \textbf{iOS (CocoaPods/SPM):} O Podfile do módulo foi revisado e foi garantido que a nova versão do SDK fosse vinculada corretamente, e que quaisquer breaking changes de API do Google SDK fossem absorvidas e adaptadas no código nativo do módulo (escrito em Swift), mantendo a estabilidade da aplicação iOS.
\end{itemize}

\subsection{Análise de Impacto e Planejamento}
A etapa inicial consistiu na análise de impacto da atualização obrigatória do Google SDK (v10 para v12). O objetivo foi mapear as breaking changes de API e os conflitos de dependência que quebravam o módulo nativo. O planejamento definiu uma abordagem de intervenção, onde foram realizados:
\begin{itemize}
    \item \textbf{Android:} Foi utilizado a propriedade Gradle Resolution Strategy para forçar a nova versão (v12) e garantir a coexistência com outras dependências do projeto.
    \item \textbf{iOS:} Mapeamento das APIs depreciadas e preparação da refatoração do código nativo em Swift, além de atualizar o Podfile.
\end{itemize}

\subsection{Desenvolvimento e Correção Nativa (Multiplataforma)}
Esta foi a etapa de execução técnica da correção, dividida por plataforma:
\begin{itemize}
    \item \textbf{Android (Gradle):} O arquivo build.gradle do módulo foi modificado para atualizar explicitamente a dependência. A resolutionStrategy foi aplicada no build.gradle do projeto host para resolver conflitos, forçando o Google SDK v12 em todo o dependency graph. A execução de um clean build (limpeza de cache) foi essencial para garantir que o Gradle utilizasse apenas os novos artefatos.
    \item \textbf{iOS (Swift/CocoaPods):} O Podfile foi atualizado para referenciar a nova versão do Google SDK. Após a instalação dos pods, o projeto foi aberto no Xcode e o código nativo em Swift, que interagia com o SDK, foi adaptado manualmente para as novas assinaturas de método e APIs (absorvendo as breaking changes).
\end{itemize}

\subsection{Execução do módulo em um projeto de demonstração}
Devido às dificuldades no processo de build do projeto principal, a validação da crítica mudança na dependência nativa foi realizada em um aplicativo de demonstração. Esta abordagem foi adotada para agilizar o debugging, contornando o build lento do projeto principal. No ambiente isolado do sample app, foi possível:
\begin{itemize}
    \item Vincular o módulo modificado localmente.
    \item Verificar que a funcionalidade anteriormente comprometida do módulo foi restaurada.
\end{itemize}

\subsection{Publicação de nova versão da biblioteca}
Com a correção validada no "sample app", a biblioteca foi preparada para distribuição interna. O versionamento semântico foi aplicado (ex: incremento de patch ou minor), e o pacote foi publicado no registro privado (Artifactory/NPM). Esta nova versão continha as alterações de configuração nativa (build.gradle e Podfile) e o código Swift adaptado, pronta para ser consumida pelo aplicativo principal.

\subsection{Testes em ambiente de homologação (QA)}
A nova versão da biblioteca foi atualizada no aplicativo principal e um build foi gerado para o ambiente de QA. A equipe de qualidade executou um plano de testes de regressão focado:
\begin{itemize}
    \item \textbf{Validação da Correção:} Garantir que a funcionalidade do módulo estava operacional.
    \item \textbf{Validação de Coexistência (Risco do Gradle):} O teste mais crítico foi verificar se a estratégia de forçar o Google SDK v12 não introduziu efeitos colaterais ou quebrou outros módulos que pudessem depender de sub-versões diferentes dos serviços do Google.
\end{itemize}
Ambos os dois testes acima foram validados e passados com sucesso.

\subsection{Testes em ambientes pré-produtivos (Staging)}
O build aprovado em QA foi promovido ao ambiente de Staging, um espelho do ambiente de produção. Esta etapa validou a interação da aplicação com os serviços reais do Google (autenticação, mapas, etc., dependendo do SDK) utilizando as novas APIs v12. O objetivo foi garantir que a atualização de segurança e compatibilidade funcionava corretamente em um cenário de uso real antes da exposição ao cliente.

\subsection{Deploy para ambiente produtivo}
Dada a natureza da mudança (atualização de segurança e correção de breaking changes), o deploy foi tratado com monitoramento intensivo. Foi utilizado um Staged Rollout (lançamento em fases) via Play Store e App Store. A versão foi liberada inicialmente para 1\% dos usuários, com acompanhamento em tempo real das ferramentas de crash reporting (Crashlytics). Após a confirmação da estabilidade (ausência de novos crashes nativos relacionados ao Google SDK), a distribuição foi escalonada para 100\%.

\section{Desenvolvimento de um MVP de um Sistema Web (Período: início em 16/10, tarefa ainda em andamento)}

\subsection{Detalhamento da Execução}
O MVP está sendo construído e tem previsão de acabar ao longo do final das atividades previstas na disciplina.

\subsection{Design e Implementação do API Gateway e do Contrato de Comunicação Inter-serviços}
A simples criação de endpoints individuais em cada micro serviço levaria a um acoplamento forte com o front-end e a uma complexidade de gerenciamento. Aplicando os princípios de Design de Software, foi implementada uma API Gateway para desacoplamento entre regras de negócios da aplicação.

Para demonstrar a aplicação técnica, a solução foi implementada utilizando Node.js com o framework Express, devido à sua leveza e eficiência em operações de I/O.

\subsubsection{Contrato OpenAPI como Fonte da Verdade}
O primeiro passo foi definir o contrato para o endpoint público no Gateway. Foi utilizada a especificação OpenAPI (Swagger) para documentar o formato de resposta esperado pelo front-end.

\textbf{Exemplo de Caso de Uso:} Obter detalhes de um Produto, que exige dados do Serviço de Produtos e do Serviço de Avaliações.

\begin{lstlisting}[language=yaml, caption={Trecho da Especificação OpenAPI (Gateway Público)}]
# Trecho da Especificação OpenAPI (Gateway Público)
paths:
  /v1/produtos/{id}:
    get:
      summary: Retorna detalhes de um produto com suas avaliações
      responses:
        '200':
          content:
            application/json:
              schema:
                type: object
                properties:
                  produtoId: { type: integer }
                  nome: { type: string }
                  preco: { type: number }
                  # Propriedade agregada:
                  mediaAvaliacoes: { type: number, description: "Média calculada pelo Gateway" }
                  totalAvaliacoes: { type: integer }
\end{lstlisting}

\subsubsection{Orquestração e Agregação no Código do Gateway}
O código do endpoint no Gateway demonstra a orquestração paralela dos serviços internos.

\begin{lstlisting}[language=JavaScript, caption={Exemplo de código no API Gateway}]
// Exemplo de código no API Gateway (Node.js com Axios para chamadas HTTP)

const express = require('express');
const axios = require('axios');
const router = express.Router();

const URL_PRODUTOS = 'http://servico-produtos:3001/api';
const URL_AVALIACOES = 'http://servico-avaliacoes:3002/api';

// GET /v1/produtos/:id
router.get('/v1/produtos/:id', async (req, res) => {
    const produtoId = req.params.id;
    
    // 1. Centralização da Autenticação (Cross-Cutting Concern)
    // Se a rota exigisse, a validação do token JWT ocorreria aqui.

    try {
        // 2. Orquestração Paralela: Chamadas simultâneas aos microsserviços internos
        const [produtoResponse, avaliacoesResponse] = await Promise.all([
            axios.get(`${URL_PRODUTOS}/produtos/${produtoId}`),
            axios.get(`${URL_AVALIACOES}/avaliacoes/produto/${produtoId}`)
        ]);

        const produto = produtoResponse.data;
        const avaliacoes = avaliacoesResponse.data;

        // 3. Agregação e Transformação de Dados
        const media = avaliacoes.length 
                      ? avaliacoes.reduce((soma, a) => soma + a.nota, 0) / avaliacoes.length 
                      : 0;

        // 4. Retorno ao Cliente (Aderente ao Contrato OpenAPI)
        const respostaGateway = {
            produtoId: produto.id,
            nome: produto.nome,
            preco: produto.valor,
            mediaAvaliacoes: parseFloat(media.toFixed(1)),
            totalAvaliacoes: avaliacoes.length
        };

        return res.status(200).json(respostaGateway);

    } catch (error) {
        // Tratamento centralizado de erros de comunicação inter-serviços
        console.error('Erro na orquestração:', error.message);
        return res.status(500).json({ erro: 'Falha ao processar a requisição.' });
    }
});
module.exports = router;
\end{lstlisting}

\subsection{Publicação de nova versão}
Atualmente a atuação está na publicação de uma nova versão e encontra-se em andamento.
As próximas etapas previstas são:
\begin{enumerate}
    \item Publicação de uma versão
    \item Testes em ambiente de homologação (QA)
    \item Testes em ambientes pré-produtivos (pré-produção)
    \item Deploy para ambiente produtivo
\end{enumerate}
