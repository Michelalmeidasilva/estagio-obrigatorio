%
% Exemplo genérico de uso da classe unipampa.cls
%
% Se você não tem familiaridade com o LaTeX, este arquivo dá algumas orientações.
% Para um aproveitamento melhor, sugere-se usar o livro LaTeX - A Document Preparation System,
% de Leslie Lamport. Na Internet estão disponíveis também alguns milhares de tutorias.
% Na UNIPAMPA, volta e meia tem cursos, fique atento.
%
% O símbolo % é um comentário de linha, então tudo que aparecer depois dele não é considerado
% no texto final. Você pode limpar todos os comentários deste arquivo, depois que colocar os
% dados corretos, sem prejuízo do texto final.
%

\documentclass[tcc,baec]{unipampa}
% Para usar o modelo, deve-se informar o curso e o tipo de documento e o tipo de documento que deve ser produzido.
% Cursos:
%   * código do curso   -- Usar o código do curso, conforme está registrado no SIE 
%                         (baec para Engenharia de Computação, por exemplo) quando
%                         se tratar de curso de graduação; usar a sigla do programa
%                         quando se tratar de pós-graduação stricto sensu (ppgcap
%                         para o Programa de Pós-graduação em Computação Aplicada,
%                         por exemplo; para especializações, definir os campos
%                         apropriadamente com o comando \course{nome-do-curso}
%                         (sem o termo ``Especialização'') e \campus{nome-do-campus}.
%   
% Tipos de Documento:
%   * tcc               -- Trabalhos de Conclusão de Curso
%   * espec             -- Monografias de Especialização
%   * mestrado          -- Dissertações de Mestrado (acadêmico)
%   * mestradoprof      -- Dissertações de Mestrado (profissional)
%   * doutorado         -- Teses de Doutorado
%   * projetotcc 				-- Projeto de TCC
%   * projetoespec   		-- Projeto de Especialização
%   * projetomestrado		-- Projeto de qualificação de Mestrado
%   * projetodoutorado	-- Projeto de qualificação de Doutorado
%   * relatorio         -- Relatório de projeto (precisa ter o curso de origem e não tem muitos detalhes - trabalho em andamento)
% 
% Outras Opções:
%   * english    -- para textos em inglês
%   * openright  -- força início de capítulos em páginas ímpares (padrão da biblioteca)
%   * oneside    -- desliga frente-e-verso
%   * final      -- versão final do texto
% 

% Programas de pós-graduação com mais de uma área de concentração devem declarar explicitamente
% a área de concentração da dissertação ou tese, por meio do comando
%\renewcommand{\areacourse}{Sanidade Animal}

\usepackage[T1]{fontenc}        % pacote para conj. de caracteres correto
\usepackage[utf8]{inputenc}     % pacote para acentuação
\usepackage{graphicx}           % pacote para importar figuras
\usepackage{times}              % pacote para usar fonte Adobe Times
\usepackage{mathptmx}           % pacote usar fonte Adobe Times nas fórmulas
\usepackage{color}

\usepackage[alf,abnt-emphasize=bf]{abntex2cite}    % pacote para usar citações abnt
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{longtable}
\usepackage{textcomp}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{DarkGreen},
  commentstyle=\color{gray}\itshape,
  identifierstyle=\color{black},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  breaklines=true,
  frame=single,
  showstringspaces=false,
  tabsize=2,
  captionpos=b
}
\usepackage[svgnames]{xcolor}
\usepackage{csvsimple}
\usepackage{rotating}
\usepackage{multirow}
\usepackage[final]{pdfpages}

%%%%%%%%%%%% Macros bem jeitosas - a macro obso serve para o seu orientador escrever comentários no
%%%%%%%%%%%% texto, que vão aparecer em azul. A macro \obsa serve para você escrever, e os seus comentários
%%%%%%%%%%%% vão aparecer em laranja. Quando você quiser gerar uma versão sem comentários, comente, com um %
%%%%%%%%%%%% a macro que contém texto e descomente a que não tem. Voilá! Todos os comentários vão desaparecer.

\newcommand{\obso}[1]{\textcolor{blue}{#1}}
%\newcommand{\obso}[1]{}
\newcommand{\obsa}[1]{\textcolor{orange}{#1}}
%\newcommand{\obsa}[1]{}

% Redefine fonte command for left-aligned sources with spacing
\makeatletter
\renewcommand{\fonte}[1]{%
  \par\vspace{0.3em}%
  \begin{flushleft}%
    {\small Fonte: #1}%
  \end{flushleft}%
}
\makeatother


      

% Adjust header height to accommodate the logo
\usepackage{geometry}
\geometry{headheight=2.5cm, headsep=0.5cm}

% Redefine the page style to include the logo in the header
\makeatletter
\renewcommand{\ps@iiufrgs}{
        \let\@oddfoot\@empty
        \let\@evenfoot\@empty
        \def\@evenhead{\hbox to \textwidth{\rlap{\small\thepage}\hfil\includegraphics[height=2cm]{../unipampa.png}\hfil}}
        \def\@oddhead{\hbox to \textwidth{\hfil\includegraphics[height=2cm]{../unipampa.png}\hfil\llap{\small\thepage}}}
}
\makeatother

\begin{document}

\includepdf[pages=-]{primeiras-paginas.pdf}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Aqui comeca o texto propriamente dito. O texto pode ser todo escrito neste 
% mesmo arquivo, mas pode-se separar o texto em diversos arquivos, que podem
% ser incluídos com o comando \input{nome-do-arquivo} (inclui o arquivo com
% nome nome-do-arquivo.tex), que deve estar no mesmo diretório do texto
% principal. Se estiver em outro diretório, pode ser incluído também, usando
% .. (para subir na árvore de diretórios) ou / (para descer), como em
% \input{Textos/nome-do-arquivo}. Dessa forma, o arquivo será buscado no
% subdiretório Textos; se quiser usar caminhos na árvore de diretórios, use
% \input{../Textos/nome-do-arquivo}, que procura o arquivo que está no diretório
% Textos, um nível acima na estrutura.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% E aqui vai a parte principal:


 


\newpage



\chapter{Referencial Teórico}

As bases técnicas que nortearam a execução das atividades foram a adoção de quatro pilares fundamentais: uma arquitetura de microsserviços, a aplicação dos princípios SOLID, a utilização de um Design System e diferentes linguagens e frameworks. Essa combinação permitiu a entrega de produtos e funcionalidades de forma incremental, consistente e evolutiva, conforme preconizado pelo Manifesto Ágil \cite{agile}.

\section{Conceitos e Metodologias de Desenvolvimento}

Para garantir a qualidade e a manutenibilidade do software, foram adotados os seguintes conceitos e metodologias:

\begin{description}
    \item[Engenharia de Software:] É a aplicação de uma abordagem sistemática, disciplinada e quantificável para o desenvolvimento, operação e manutenção de software \cite{pressman}.
    \item[Metodologia Ágil:] É uma abordagem iterativa para o gerenciamento de projetos e desenvolvimento de software que ajuda as equipes a entregar valor aos seus clientes de forma mais rápida e com agilidade de entrega das funcionalidades.
    \item[Scrum:] É um dos frameworks mais populares para a implementação de desenvolvimento ágil. Ele é projetado para que equipes possam entregar valor ao cliente de forma incremental e iterativa \cite{scrum}.
    \item[Código Limpo (Clean Code):] É uma filosofia de desenvolvimento de software popularizada por Robert C. Martin (``Uncle Bob''). A premissa é que o código deve ser escrito de forma simples, direta e legível, como uma prosa bem escrita. Suas características incluem o uso de nomes significativos para variáveis e funções, funções pequenas com responsabilidades únicas e a minimização de complexidade.
    \item[Arquitetura Limpa (Clean Architecture):] Também concebida por Robert C. Martin, é um modelo de design de software que impõe uma rigorosa separação de responsabilidades. A arquitetura é representada por círculos concêntricos, onde a regra principal é a Regra da Dependência: as dependências do código-fonte só podem apontar para dentro. Nada em um círculo interno pode saber qualquer coisa sobre um círculo externo.
    \item[Princípios SOLID:] É um acrônimo para cinco princípios de design de software que visam tornar o código mais compreensível, flexível e manutenível \cite{cleanarch}:
    \begin{itemize}
        \item \textbf{S} - Single Responsibility Principle
        \item \textbf{O} - Open/Closed Principle
        \item \textbf{L} - Liskov Substitution Principle
        \item \textbf{I} - Interface Segregation Principle
        \item \textbf{D} - Dependency Inversion Principle
    \end{itemize}
    \item[Design Patterns (Padrões de Projeto):] São soluções gerais e reutilizáveis para problemas frequentes no desenvolvimento de software. Popularizados pelo ``Gang of Four'' (GoF), são categorizados em:
    \begin{itemize}
        \item \textbf{Criação:} Abstraem o processo de instanciação de objetos (ex: Factory, Singleton).
        \item \textbf{Estruturais:} Combinam classes e objetos para formar estruturas maiores (ex: Adapter, Decorator).
        \item \textbf{Comportamentais:} Tratam da comunicação e responsabilidades entre objetos (ex: Strategy, Observer).
    \end{itemize}
\end{description}

\section{Arquitetura de Software}

A arquitetura do sistema evoluiu de modelos tradicionais para abordagens mais modernas e distribuídas.

\begin{description}
    \item[Arquitetura Monolítica:] Modelo tradicional onde a aplicação é uma única unidade coesa. Todos os componentes do sitema são fortemente acoplados.
    \item[Arquitetura de Microsserviços:] Padrão onde uma aplicação complexa é composta por serviços pequenos e independentes, cada um com uma capacidade de negócio específica, comunicando-se via Interface de Programação de Aplicações (APIs) \cite{microservices}.
    \item[Computação Serverless:] Permite construir e executar aplicações sem gerenciar servidores.
    \begin{itemize}
        \item \textbf{Cloud Functions:} Funções de propósito único, orientadas a eventos, que escalam automaticamente.
    \end{itemize}
    \item[O Padrão API Gateway:] Atua como ponto único de entrada para requisições, encapsulando a estrutura interna de microsserviços. Seus benefícios incluem desacoplamento, orquestração de dados e centralização de funcionalidades transversais (autenticação, logging).
\end{description}

\section{Tecnologias de Desenvolvimento}

\subsection{Desenvolvimento Web}

\begin{description}
    \item[Node.js:] Ambiente de execução JavaScript (JS) assíncrono construído sobre o motor V8. Seu modelo de I/O não bloqueante o torna ideal para microsserviços e APIs de alta performance \cite{nodejs}.
    \item[React:] Biblioteca JS para construção de interfaces de usuário baseada em componentes e declarativa. Utiliza o Virtual do Document Object Model (DOM) para atualizações eficientes \cite{react}. Conceitos chave incluem Componentes, Reatividade, Gerenciamento de Estados e Hooks.
    \item[Next.js:] Framework React para produção que oferece renderização híbrida (Server Side Rendering e Static Site Generation) e sistema de roteamento baseado em arquivos \cite{nextjs}.
\end{description}

\subsection{Desenvolvimento Mobile}

\begin{description}
    \item[Ecossistema Android:] Sistema operacional móvel baseado em Linux. O desenvolvimento moderno utiliza Kotlin (interoperável com Java) e o sistema de build Gradle.
    \item[Ecossistema iOS:] Sistema proprietário da Apple. O desenvolvimento utiliza Swift (sucessor do Objective-C) e gerenciamento de dependências via Swift Package Manager ou CocoaPods.
    \item[React Native:] Framework para desenvolvimento multiplataforma usando JS e React \cite{reactnative}.
    \begin{itemize}
        \item \textbf{Arquitetura Legada (Bridge):} Baseia-se em uma comunicação assíncrona onde mensagens JavaScript Object Notation  (JSON) são serializadas e enviadas através de uma ``ponte'' entre as threads JS e Nativa. Esse processo de serialização/desserialização introduz um gargalo de performance (overhead), especialmente em aplicações que exigem alta frequência de troca de dados, como animações e gestos.

        \item \textbf{Nova Arquitetura} A nova arquitetura JS Interface (JSI)} representa uma evolução fundamental no React Native. Diferente da arquitetura legada, que dependia de serialização assíncrona de mensagens JSON, a JSI permite que o código JS mantenha referências diretas a objetos C++ (Host Objects). Isso possibilita a invocação síncrona de métodos nativos, eliminando o overhead de serialização e permitindo o compartilhamento de memória entre os runtimes. O resultado é uma interoperabilidade mais rápida e eficiente, essencial para bibliotecas de alta performance e animações complexas. A Figura \ref{fig:com_async} ilustra o processo de criação de um componente e as funções que possibilitam a comunicação entre o código React Native e os módulos nativos.
    \end{itemize}


    \begin{figure}[h!]
        \centering
        \caption{Comunicação JSI entre React-native e Nativo.}
        \label{fig:com_async}
        \includegraphics[scale=0.25]
        {IMAGENS/comunicao-async-rn-2.png} % Placeholder para a imagem
        \vspace{0.3em}
        \newline
        {\small Fonte: Do próprio autor.}
    \end{figure}
    
    \end{itemize}
    \item \textbf{React-native-builder-bob} para criação de bibliotecas e \textit{Upgrade Helper} para migração de versões.
\end{description}

\section{Design e Qualidade de Software}

\begin{description}
    \item[Design System:] Fonte única de verdade para design e desenvolvimento. O Design System provê tokens, componentes e documentação para garantir consistência.
    \item[Chrome DevTools:] Ferramentas de desenvolvimento embutidas no Chrome para inspeção de DOM, depuração de JS e análise de rede/performance.
    \item[Lighthouse:] Ferramenta de auditoria automatizada que avalia Performance, Acessibilidade, Boas Práticas e Otimização para Mecanismos de Busca (SEO).
    \item[Web Vitals:] Iniciativa do Google para métricas de qualidade de experiência do usuário.
    \begin{itemize}
        \item \textbf{Core Web Vitals:} Largest Contentful Paint (LCP), Largest Contentful Paint (CLS) e Interaction to Next Paint (INP).
    \end{itemize}
\end{description}

\section{Inteligência Artificial e Agentes}

\begin{description}
    \item[Agentes Conversacionais:] Evolução do Dialogflow CX, integrando fluxos determinísticos (baseados em estados) e generativos.
    \item[RAG (Retrieval-Augmented Generation):] Técnica que otimiza respostas de Large Language Models (LLM) usando bases de conhecimento confiáveis (Data Stores).
    \item[Model Context Protocol (MCP):] Padrão aberto para conectores seguros entre dados e ferramentas de IA.
    \item[Agent Development Kits (ADK):] Frameworks para construção de agentes autônomos.

  \item[Processamento de Linguagem Natural (NLP):] Trata-se do ramo da Inteligência Artificial que permite às máquinas compreender e gerar a linguagem humana. Unindo computação e linguística, essa tecnologia é a base para o funcionamento eficaz de chatbots, tradutores e assistentes de voz.
\end{description}

\input{TEXTO/atividades-parte-a}

\input{TEXTO/atividades-parte-b}

\input{TEXTO/atividades-parte-c}


%
% O arquivo de formatação abntex2-alf.bst coloca todas as entradas no formato correto.
%

\bibliographystyle{abntex2-alf}
\bibliography{TEXTO/TEXTO-Bibliografia}


\includepdf[pages=-]{ultimas-paginas.pdf}


\appendix
\input{TEXTO/apendice-migracao}
\input{TEXTO/apendice-api}


\end{document}
